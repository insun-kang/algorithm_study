# 해결방법

- DFS : 스택 / BFS : 큐를 활용하여 해결한다.

> BFS(너비 우선 탐색)이란?
- 한 단계 진행 시 가능한 경우의 수, 두 단계 진행 시 가능한 경우의 수 ... 이렇게 트리를 넓히면서 탐색하는 알고리즘이 바로 BFS 입니다.
- 매 단계에서 모든 경우의 수를 탐색
- 장점 : 답이 되는 경로가 여러개인 경우에도 최단 경로 보장, 최단 경로가 존재하면 깊이가 무한정 깊어도 답을 찾을 수 있다
- 단점 : 경로가 길 경우 많은 기억 공간 필요, 해가 존재하지 않는 유한 그래프의 경우 모든 그래프를 탐색 후 실패로 끝난다, 무한 그래프의 경우 해를 찾지도 끝내지도 못한다.

> 순간이동 (현재위치 * 3)에 우선순위를 두기 위해, 곱하기 인 경우 큐의 좌측에 삽입하여 먼저 처리 될 수 있도록 하였다.
```
from collections import deque

def bfs(start) :
```
    > 시작 위치와, 인접한 점들을 순차적으로 탐색할 큐를 생성한다
    ```
    queue = deque([start]) 
    ```
    > 큐가 비어있을 때까지 반복, 큐의 가장 왼쪽 원소를 pop()하여 현재 위치(now)로 설정한다.
    ```
    while queue : 
        now = queue.popleft() 
    ```
        > queue내에 k가 있으면 popleft()를 반복하다보면 now==k가 되어서 리턴된다, 목표위치까지 도달하기 위해 최단거리로 이동한 횟수를 리턴한다.
        ```
        if now == k :
            return visited[now]
        ```
        > 현재 위치의 인접한 원소로는(그래프로 생각하기) now-1, now+1, now*3이 있고, now*3을 사용가능한 경우 높은 우선순위(가중치)를 가져야 한다.
        ```
        for i in (now-1, now+1, now*3) : # i는 다음 위치(now의 인접 원소)
        ```
            > 섹터 범위 내로 i(next) 제한, visited[i] 리스트가 비어있지 않으면
            ```
            if 0 <= i < max_len and not visited[i] : 
            ```
                > 목표 위치(k)가 now*3(i)보다 같거나 큰 경우 i가 최대 섹션을 넘어가지 않는다면
                ```
                if k >= now*3 == i and i < max_len : 
                    visited[i] = visited[now] + 1 # 다음 인접원소로 이동하기 위한 횟수는 현재 원소로 이동하기 위한 횟수 + 1
                    queue.appendleft(i) # 큐의 좌측에(우선처리 됨) i를 삽입한다
                    # print(queue)
                ```
                > k가 now*3보다 작다면
                ```
                else : 
                    visited[i] = visited[now] + 1 # 다음 인접원소로 이동하기 위한 횟수는 현재 원소로 이동하기 위한 횟수 + 1
                    queue.append(i) # 1씩 이동하는 인접 원소들을 큐에 삽입한다.(제일 나중에 체크)  
                ```

> 정의한 bfs 함수를 이용하여 n에서 k로 이동할 때 소요된 초를 출력하는 메인함수
```
if __name__ == '__main__' :
    max_len = 100000
    n, k = map(int, input().split())
    visited = [0] * max_len # 최단거리로 n이 k로 갈 때 걸리는 횟수(초)를 측정하기 위한 리스트 변수
    print(bfs(n))
```

# 범인 찾기

먼 미래에 경찰은 공간이동이 가능합니다. 이곳의 공간은 0부터 100,000까지 순서대로 섹터가 존재하며 일직선으로 이루어져 있습니다.

범인이 K 섹터에 있을 때, 경찰이 N 섹터에서 범인을 가장 빨리 찾을 수 있는 시간이 몇 초인지 출력하는 프로그램을 작성하세요.

공간이동을 사용할 경우 경찰의 위치가 X일 때 1초 후에 3*X3∗X의 섹터로 이동합니다.
공간이동을 사용하지 않을 경우는 섹터 X에서 1초 후에 X-1 또는 X+1만큼 이동합니다.


## [입력]
첫 번째 줄에 경찰이 위치한 섹터 자연수 N과 범인의 위치한 섹터 자연수 K를 입력합니다.
```(1 ≤ N, K ≤ 100,000)```

## [출력]
첫 번째 줄에 경찰이 범인을 찾는 가장 이른 시간을 출력합니다.

## [입력 예시]
5 17

## [출력 예시]
3